The brief for this assignment was to create either a non-linear hypertext story or an "interactive surface" - a web page with interactive elements (through mouse or keyboard) uses Javascript and is animated using the Canvas API.

I chose to make a music sequencer, where notes displayed as coloured shapes are placed on a grid to make simple melodies. I wanted it to be intuitive to use, and more of a toy than for creating actual music, so features like recording a melody aren't as important as the interface.

The sequencer exists on a single webpage, with two HTML canvas elements, and some numerical inputs for changing the play speed and dimensions of the sequencer, and buttons for randomising and clearing all notes. The left canvas displays the sequencer as a grid of square note-slots, and the right canvas is the "palette", for selecting notes to paint onto the grid.

At the top of the palette is a preview of the note to be placed, and the dot placeholder icon that indicates there is no note present. Clicking the note preview allows the note to be copied to the sequencer, and clicking the placeholder allows notes to be deleted. Below this are variants of the preview note - the same shape is displayed in different hues to indicate different notes, different brightnesses for octaves, and different shapes for each synthesiser. Clicking any of these changes the note to be placed.

A cursor moves across the sequencer grid, left-to-right, top-to-bottom, playing each note when reached, and pausing between each note for an amount of time equal to the "tempo" input in milliseconds. The dimensions of the grid can be customised to allow longer melodies or more precise placement of notes. No data is lost when shrinking the grid - the notes are stored in a 2-dimensional array and only erased when the user specifically deletes a note. The current dimensions and greatest dimensions of the grid are stored separately, and the sequencer only displays and plays the currently "active" portion of the grid as determined by the number inputs.

Notes are displayed as differently-coloured shapes. The hue of the shape represents the frequency (C, D, etc) and the brightness indicates the octave, so darker shapes indicate deeper sounds. This is because shapes in a melody will usually be close in terms of octaves, and it's more important to distinguish between different notes in the same octave. The notes CDEFGAB are displayed in red, orange, yellow, green, teal, blue, and violet respectively, and sharp notes have a white hole in the middle. The oscillating hues are appropriate because violet is still close to red, indicating C comes immediately after B. There are seven "base" hues whose RGB values are multiplied according to the octave, then added to the square of the octave. This gives the higher notes a more "pastel" colour, distinguishing them from the middle octaves. The actual shape of a note indicates which synthesiser is used to play it.

The sound is played with the Tone.js audio library, which provides many tools for synthesising and playing back audio. This project just uses it to play single notes from 5 of the premade synthesisers in the library. My original idea was to find audio samples of various instruments that I would pitch up or down to match different notes, but I switched to synthesising notes because I couldn't find what I needed online. This would still be fairly simple to implement because Tone.js includes a sampler synthesiser that automatically does this with a given audio file.

The design of the sequencer is very minimalistic, having no text besides the options at the bottom. This is a stylistic choice that I think is still appropriate - even if actual musical terminology is not used, the layout of the notes and octave on the palette suggests the Western musical notes, with 7 hues, the 1st, 2nd, 4th, 5th and 6th of which have slightly modified variants. The placeholder icon is very small, indicating visually that less is present in a placeholder than in any other notes. The fact that the palette options update as the note to be placed is edited indicates that each section represents a change to one aspect of the note. The different hues take up most of the space on the palette, reflecting the fact that they're the most important thing for creating a melody.

Although I added the "randomise" button as a debug option, I decided to keep it after playing with it a bit. I found it could be used to create interesting melodies by clicking it a few times until it inevitably produces some combination of notes that sounds good, then removing all "noise" notes until only the desired notes remain. I thought this "backwards" method was an interesting and compelling creative tool. It feels rewarding to sift some interesting sounds out of a sea of noise.

Something I would have liked to implement is a way to sample and play back created melodies. This would allow a copy of a synthesiser to be saved into a side bar, where the melody stored in it could be played back along with the current layout of the sequencer. This could be accomplished by having multiple copies of the 2D "grid" array in another array, with individual cursors and synthesisers for each one. This would allow the user to make much more complex melodies, and to edit different tracks separately.

A major feature that's missing from the final product is the ability to export created melodies. Again, this wasn't a part of my original idea but it wouldn't be too hard to implement if necessary. Melodies could be saved and loaded to and from the sequencer program by just saving the note data as a string ("C#4-basic; E5-duo; D#5-duo" etc.) as well as metadata (grid dimensions and tempo).